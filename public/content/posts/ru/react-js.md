---
title: React.js
excerpt: React — библиотека JavaScript для веб- и нативных пользовательских интерфейсов
image: react.png
isFeatured: true
date: "2024-04-05"
---

# React

## React и чистый JavaScript:

- Код на React более читаем (JSX = JS + HTML в одном файле)
- Компоненты
- JS императивный (буквально даёшь пошаговые инструкции)
- React декларативный (описываешь, что именно хочешь получить)

```javascript
// Императивный подход
const element = document.createElement("p");
element.appendText = "example";
element.className = "styles";
element.addEventListener("click", function () {});
// Декларативный
<p className="styles" onClick={function () {}}>
  example
</p>;
```

## Виртуальный DOM

- Виртуальный DOM представляет собой упрощённые объекты JavaScript по сравнению с настоящим DOM.

## Сверка (Reconciliation)

- Это процесс сравнения старой и новой версий (снимков) виртуального DOM после изменения данных (например, массива, на основе которого отображается список).
- На основе этой сверки React вносит точечные изменения в реальный DOM.
- В итоге пользователь видит обновление только изменённого элемента списка, а не полную перерисовку.

## Базовые хуки

### useState

- Локальное состояние
- Сравнивает предыдущие значения с новыми и при необходимости вызывает повторный рендер тех частей UI, которые от него зависят (в отличие от обычной переменной, которую мы вывели бы в JSX и изменили в обработчике события)
- правильное изменение состояния `setState(prev => prev + 1)`
- `useState(compute())` — можно передать функцию в качестве начального значения, чтобы вычислить его один раз, а не при каждом рендере

### useRef

- Можно использовать как useState, но **изменение не вызывает повторный рендер**
- Также может хранить ссылку на DOM-элемент

### useContext

- Нужен для избежания **props drilling**, когда приходится пробрасывать состояние через пропсы каждого уровня, даже там, где оно не нужно
- TODO: React context vs state manager libs (Redux vs Zustand vs React-Query vs React Context)

### useCallback <span id="useCallback"></span>

1. Используется вместе с [React.memo](#React.memo) для функций, передаваемых в дочерний компонент, чтобы между рендерами родителя сохранялась та же ссылка.

### useMemo <span id="useMemo"></span>

Сценарии использования:

1. Аналогично useCallback, в дополнение к [React.memo](#React.memo), но для объектов, массивов и т.д.
2. Когда одно из состояний сложно вычисляется, а мы изменяем другое состояние, при ререндере сложное состояние пересчитывается снова.

```javascript
function formatData() {
  return data.map((item) => {
    // сложные вычисления (форматирование, сортировка, фильтрация)
  });
}
const formattedData = useMemo(formatData, [data]);
```

## Оптимизация

### Атрибут `key`

- Нужен для оптимизации обновления списка элементов, созданного с помощью метода `map`.
- Если мы добавляем новый элемент в начало или середину массива,
  React с `key` сможет корректно сопоставить существующие элементы и обновить **только изменённые**,
  избегая полной перерисовки всех элементов.

### React.lazy

- Нужен, когда не хотим, чтобы компонент попадал в начальный бандл (собранный файл из всех файлов проекта).
- Начальная загрузка будет быстрее (бандл меньше), но пользователь будет ждать, когда компонент подгрузится.
- Такой компонент следует оборачивать в `React.Suspense` и указывать загрузчик в `fallback` (бандл делится на чанки).

### Оптимизация повторных рендеров дочерних компонентов

- Без PureComponent / shouldComponentUpdate / React.memo **компоненты перерисовываются каждый раз при ререндере родителя независимо от изменения пропсов.**

```javascript
// UserName будет перерисовываться каждый раз при клике на кнопку
<>
  <button onClick={() => setState((prev) => prev + 1)}>Add</button>
  <UserName name="John Doe" />
</>
```

#### PureComponent

- При наследовании от `PureComponent` сравниваются новые и старые props и state, предотвращая ререндер, если они одинаковые.

#### shouldComponentUpdate(nextProps, nextState)

- Делает то же, но в этом методе жизненного цикла можно реализовать **пользовательскую логику сравнения** props и state.

#### HOC React.memo

- Делает то же для функциональных компонентов и только для props.
- Предотвращает ререндер, когда props не изменились.

```javascript
// не будет перерисовываться при рендере родителя, только при изменении props.name
const UserName = React.memo((props) => {
  return <div>{props.name}</div>;
});
```

- <span id="React.memo" style="color:red;font-size:25px;">!!!</span> React.memo / PureComponent делают **только поверхностную проверку** (примитивы и ссылки).
- Когда в пропс передан не примитивный тип, дополнительно к React.memo
  данные нужно обернуть в [useMemo](#useMemo) / [useCallback](#useCallback).
- Использование этих хуков сохраняет ссылки на функции и объекты между рендерами, предотвращая лишние перерисовки.

```javascript
const user = useMemo(() => ({ name: "John Doe" }), []);
const handleClick = useCallback(() => setState((prev) => prev + 1), []);
return (
  <>
    <UserName user={user} />
    <button onClick={handleClick}>Add</button>
  </>
);
```

## Продвинутые хуки

### useLayoutEffect

- Применяется, когда нужно напрямую изменить стили в DOM-дереве (`ref.current.style.border = "1px solid black"`)
- и хотим, чтобы они применились **до отрисовки — синхронно**, а не после рендера, как в обычном useEffect.

### useImperativeHandle

- Нужен, когда из родительского компонента, например, нужно очистить поля, привязанные к локальному состоянию дочернего.
- Через `forwardRef` в дочернем компоненте раскрываются методы, которые доступны только внутри него, а в родительском их можно вызвать через ссылку.

### useTransition

- Используем, когда тяжёлый ререндеринг влияет на отзывчивость страницы.
- С его помощью можно приоритизировать состояния, влияющие на отзывчивость (текстовый ввод, переключение табов, таймлайн).
- И понизить приоритет состояния, блокирующего интерфейс (рендер результатов фильтрации списка по вводу, переключение содержимого таба).

```javascript
const [input, setInput] = useState("");
const [list, setList] = useState([]);
const [isPending, startTransition] = useTransition();

function handleChange(e) {
  setInput(e.target.value); // устанавливаем приоритетное состояние
  startTransition(() => {
    const filteredValue = data.filter((item) => item); // тяжёлые вычисления фильтрации
    setList(filteredValue); // состояние с меньшим приоритетом внутри startTransition
  });
}
```

# Важные библиотеки, связанные с React

## React-router-dom V6

TODO: Через роутер можно фетчить данные

## Redux

- Redux хранит состояние объектов в едином store
- Чтобы изменить состояние, нужно отправить action; action попадает в reducer, reducer описывает, как изменится state
- Изменения происходят только с помощью **чистой** функции reducer — создаются копии и подменяются
- ACTION — простой объект { type, payload }
- Методы `dispatch(action)`, `getState()`, `subscribe(listener)` принадлежат store (`store.dispatch`)
- mstp выбирает нужную для компонента часть state и отслеживает изменения в выбранных свойствах
- FLOW — dispatch(action) -> reducer(current state, action) -> возвращается новый экземпляр state

## Redux-toolkit

- Не используем ActionCreators
- Используем `ThunkCreator.fulfilled/rejected` для успешных/неуспешных случаев санок
- Настраиваем санки не на диспатч нужного AC, а на возврат данных/rejectedWithValue(error)

## Redux-thunk

- Middleware для Redux, позволяющий диспатчить асинхронные действия (thunks)
